import re
import json
from typing import Dict, Any, List, Optional
from pydantic import BaseModel, Field

from kodiak.core.tools.base import KodiakTool, ToolResult
from kodiak.services.executor import get_executor


class SQLMapArgs(BaseModel):
    url: str = Field(..., description="Target URL to test for SQL injection")
    data: Optional[str] = Field(None, description="POST data string for testing")
    cookie: Optional[str] = Field(None, description="HTTP Cookie header value")
    user_agent: Optional[str] = Field(None, description="HTTP User-Agent header value")
    headers: Optional[str] = Field(None, description="Extra HTTP headers (e.g., 'Header1: value1\\nHeader2: value2')")
    method: Optional[str] = Field("GET", description="HTTP method (GET, POST, PUT, etc.)")
    level: int = Field(1, description="Level of tests to perform (1-5, higher = more tests)")
    risk: int = Field(1, description="Risk of tests to perform (1-3, higher = more dangerous)")
    technique: Optional[str] = Field(None, description="SQL injection techniques (B,E,U,S,T,Q)")
    dbms: Optional[str] = Field(None, description="Force back-end DBMS (mysql, oracle, postgresql, etc.)")
    batch: bool = Field(True, description="Never ask for user input, use default behavior")
    threads: int = Field(1, description="Max number of concurrent HTTP requests")


class SQLMapTool(KodiakTool):
    name = "sqlmap"
    description = "Automatic SQL injection detection and exploitation tool. Tests web applications for SQL injection vulnerabilities."
    args_schema = SQLMapArgs

    @property
    def parameters_schema(self) -> Dict[str, Any]:
        return {
            "type": "object",
            "properties": {
                "url": {
                    "type": "string",
                    "description": "Target URL to test (e.g., https://example.com/page?id=1)"
                },
                "data": {
                    "type": "string",
                    "description": "POST data for testing (e.g., 'username=admin&password=test')"
                },
                "cookie": {
                    "type": "string",
                    "description": "HTTP Cookie header (e.g., 'PHPSESSID=abc123; user=admin')"
                },
                "user_agent": {
                    "type": "string",
                    "description": "Custom User-Agent string"
                },
                "headers": {
                    "type": "string",
                    "description": "Additional HTTP headers, newline separated"
                },
                "method": {
                    "type": "string",
                    "description": "HTTP method to use (GET, POST, PUT, DELETE)"
                },
                "level": {
                    "type": "integer",
                    "description": "Test level 1-5 (1=basic, 5=comprehensive)"
                },
                "risk": {
                    "type": "integer", 
                    "description": "Risk level 1-3 (1=safe, 3=destructive tests)"
                },
                "technique": {
                    "type": "string",
                    "description": "Injection techniques: B(Boolean), E(Error), U(Union), S(Stacked), T(Time), Q(Inline)"
                },
                "dbms": {
                    "type": "string",
                    "description": "Target DBMS (mysql, postgresql, oracle, mssql, sqlite)"
                },
                "batch": {
                    "type": "boolean",
                    "description": "Run in batch mode (no user interaction)"
                },
                "threads": {
                    "type": "integer",
                    "description": "Number of concurrent threads (1-10)"
                }
            },
            "required": ["url"]
        }

    async def _execute(self, args: Dict[str, Any]) -> ToolResult:
        url = args["url"]
        
        # Build sqlmap command
        command = [
            "sqlmap",
            "-u", url,
            "--batch" if args.get("batch", True) else "",
            "--level", str(args.get("level", 1)),
            "--risk", str(args.get("risk", 1)),
            "--threads", str(args.get("threads", 1)),
            "--output-dir", "/tmp/sqlmap_output",
            "--flush-session"  # Start fresh
        ]
        
        # Remove empty strings
        command = [cmd for cmd in command if cmd]
        
        # Add optional parameters
        if args.get("data"):
            command.extend(["--data", args["data"]])
        if args.get("cookie"):
            command.extend(["--cookie", args["cookie"]])
        if args.get("user_agent"):
            command.extend(["--user-agent", args["user_agent"]])
        if args.get("headers"):
            command.extend(["--headers", args["headers"]])
        if args.get("method") and args["method"] != "GET":
            command.extend(["--method", args["method"]])
        if args.get("technique"):
            command.extend(["--technique", args["technique"]])
        if args.get("dbms"):
            command.extend(["--dbms", args["dbms"]])
        
        cmd_str = " ".join(command)

        try:
            executor = get_executor()
            result = await executor.run_command(command)
            
            # SQLMap returns various exit codes, not just 0/1
            # Parse output to determine if vulnerabilities were found
            vulnerabilities = self._parse_sqlmap_output(result.stdout)
            
            success = result.exit_code in [0, 1]  # 0 = no vuln, 1 = vuln found
            
            return ToolResult(
                success=success,
                output=result.stdout,
                data={
                    "command": cmd_str,
                    "url": url,
                    "vulnerabilities": vulnerabilities,
                    "vulnerable": len(vulnerabilities) > 0,
                    "exit_code": result.exit_code,
                    "summary": self._generate_summary(url, vulnerabilities)
                },
                error=result.stderr if not success else None
            )
            
        except Exception as e:
            return ToolResult(
                success=False,
                output=f"SQLMap execution failed: {str(e)}",
                error=str(e)
            )

    def _parse_sqlmap_output(self, output: str) -> List[Dict[str, Any]]:
        """Parse SQLMap output to extract vulnerability information"""
        vulnerabilities = []
        lines = output.split('\n')
        
        current_param = None
        current_vuln = {}
        
        for line in lines:
            line = line.strip()
            
            # Parameter being tested
            param_match = re.search(r"testing '([^']+)'", line)
            if param_match:
                current_param = param_match.group(1)
            
            # Vulnerability found
            if "is vulnerable" in line.lower():
                vuln_match = re.search(r"Parameter: ([^\s]+).*?Type: ([^\s]+)", line)
                if vuln_match:
                    param = vuln_match.group(1)
                    vuln_type = vuln_match.group(2)
                    
                    vulnerability = {
                        "parameter": param,
                        "type": vuln_type,
                        "description": line,
                        "severity": self._assess_sqli_severity(vuln_type)
                    }
                    vulnerabilities.append(vulnerability)
            
            # Database information
            if "back-end DBMS:" in line:
                dbms_match = re.search(r"back-end DBMS: (.+)", line)
                if dbms_match and vulnerabilities:
                    vulnerabilities[-1]["dbms"] = dbms_match.group(1).strip()
            
            # Injection technique details
            if "Title:" in line:
                title = line.replace("Title:", "").strip()
                if vulnerabilities:
                    vulnerabilities[-1]["title"] = title
            
            if "Payload:" in line:
                payload = line.replace("Payload:", "").strip()
                if vulnerabilities:
                    vulnerabilities[-1]["payload"] = payload
        
        return vulnerabilities

    def _assess_sqli_severity(self, vuln_type: str) -> str:
        """Assess severity of SQL injection vulnerability"""
        vuln_type_lower = vuln_type.lower()
        
        if any(keyword in vuln_type_lower for keyword in ["union", "error", "boolean"]):
            return "HIGH"
        elif "time" in vuln_type_lower:
            return "MEDIUM"
        else:
            return "HIGH"  # Default to high for SQL injection

    def _generate_summary(self, url: str, vulnerabilities: List[Dict[str, Any]]) -> str:
        """Generate human-readable summary"""
        if not vulnerabilities:
            return f"SQLMap scan completed for {url}. No SQL injection vulnerabilities found."
        
        summary = f"SQLMap SQL Injection Test Results for {url}\n"
        summary += "=" * 50 + "\n\n"
        summary += f"VULNERABLE: {len(vulnerabilities)} SQL injection point(s) found!\n\n"
        
        for i, vuln in enumerate(vulnerabilities, 1):
            summary += f"{i}. Parameter: {vuln.get('parameter', 'Unknown')}\n"
            summary += f"   Type: {vuln.get('type', 'Unknown')}\n"
            summary += f"   Severity: {vuln.get('severity', 'HIGH')}\n"
            if vuln.get('title'):
                summary += f"   Title: {vuln.get('title')}\n"
            if vuln.get('dbms'):
                summary += f"   Database: {vuln.get('dbms')}\n"
            summary += "\n"
        
        return summary


class CommixArgs(BaseModel):
    url: str = Field(..., description="Target URL to test for command injection")
    data: Optional[str] = Field(None, description="POST data string")
    cookie: Optional[str] = Field(None, description="HTTP Cookie header value")
    user_agent: Optional[str] = Field(None, description="HTTP User-Agent header value")
    level: int = Field(1, description="Level of tests to perform (1-3)")
    technique: Optional[str] = Field(None, description="Injection technique (classic, eval-based, time-based, file-based)")
    batch: bool = Field(True, description="Never ask for user input")


class CommixTool(KodiakTool):
    name = "commix"
    description = "Automated command injection detection and exploitation tool. Tests web applications for OS command injection vulnerabilities."
    args_schema = CommixArgs

    @property
    def parameters_schema(self) -> Dict[str, Any]:
        return {
            "type": "object",
            "properties": {
                "url": {
                    "type": "string",
                    "description": "Target URL to test (e.g., https://example.com/page?cmd=test)"
                },
                "data": {
                    "type": "string",
                    "description": "POST data for testing"
                },
                "cookie": {
                    "type": "string",
                    "description": "HTTP Cookie header"
                },
                "user_agent": {
                    "type": "string",
                    "description": "Custom User-Agent string"
                },
                "level": {
                    "type": "integer",
                    "description": "Test level 1-3 (1=basic, 3=comprehensive)"
                },
                "technique": {
                    "type": "string",
                    "description": "Injection technique (classic, eval-based, time-based, file-based)"
                },
                "batch": {
                    "type": "boolean",
                    "description": "Run in batch mode"
                }
            },
            "required": ["url"]
        }

    async def _execute(self, args: Dict[str, Any]) -> ToolResult:
        url = args["url"]
        
        # Build commix command
        command = [
            "commix",
            "--url", url,
            "--batch" if args.get("batch", True) else "",
            "--level", str(args.get("level", 1))
        ]
        
        # Remove empty strings
        command = [cmd for cmd in command if cmd]
        
        # Add optional parameters
        if args.get("data"):
            command.extend(["--data", args["data"]])
        if args.get("cookie"):
            command.extend(["--cookie", args["cookie"]])
        if args.get("user_agent"):
            command.extend(["--user-agent", args["user_agent"]])
        if args.get("technique"):
            command.extend(["--technique", args["technique"]])
        
        cmd_str = " ".join(command)

        try:
            executor = get_executor()
            result = await executor.run_command(command)
            
            # Parse commix output
            vulnerabilities = self._parse_commix_output(result.stdout)
            
            return ToolResult(
                success=result.exit_code == 0,
                output=result.stdout,
                data={
                    "command": cmd_str,
                    "url": url,
                    "vulnerabilities": vulnerabilities,
                    "vulnerable": len(vulnerabilities) > 0,
                    "summary": self._generate_commix_summary(url, vulnerabilities)
                },
                error=result.stderr if result.exit_code != 0 else None
            )
            
        except Exception as e:
            return ToolResult(
                success=False,
                output=f"Commix execution failed: {str(e)}",
                error=str(e)
            )

    def _parse_commix_output(self, output: str) -> List[Dict[str, Any]]:
        """Parse Commix output for command injection vulnerabilities"""
        vulnerabilities = []
        lines = output.split('\n')
        
        for line in lines:
            if "is vulnerable" in line.lower() or "injection point" in line.lower():
                # Extract parameter and technique information
                param_match = re.search(r"Parameter '([^']+)'", line)
                technique_match = re.search(r"technique '([^']+)'", line)
                
                vulnerability = {
                    "parameter": param_match.group(1) if param_match else "Unknown",
                    "technique": technique_match.group(1) if technique_match else "Unknown",
                    "description": line.strip(),
                    "severity": "HIGH"  # Command injection is always high severity
                }
                vulnerabilities.append(vulnerability)
        
        return vulnerabilities

    def _generate_commix_summary(self, url: str, vulnerabilities: List[Dict[str, Any]]) -> str:
        """Generate human-readable summary for Commix results"""
        if not vulnerabilities:
            return f"Commix scan completed for {url}. No command injection vulnerabilities found."
        
        summary = f"Commix Command Injection Test Results for {url}\n"
        summary += "=" * 50 + "\n\n"
        summary += f"VULNERABLE: {len(vulnerabilities)} command injection point(s) found!\n\n"
        
        for i, vuln in enumerate(vulnerabilities, 1):
            summary += f"{i}. Parameter: {vuln.get('parameter', 'Unknown')}\n"
            summary += f"   Technique: {vuln.get('technique', 'Unknown')}\n"
            summary += f"   Severity: {vuln.get('severity', 'HIGH')}\n"
            summary += f"   Description: {vuln.get('description', '')}\n\n"
        
        return summary
